<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
</script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Breaker Géocaching</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            text-align: center;
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(to bottom, #1e3c72, #2a5298);
            color: #fff;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
        }
        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 1;
        }
        #info {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin: 0 auto 10px;
            font-size: 24px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        #restart, #playButton {
            background-color: #ff4500;
            color: #fff;
            border: 3px solid yellow;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            position: relative;
            z-index: 2;
            display: inline-block;
            margin-top: 20px;
            animation: pulse 2s infinite;
        }
        #restart:hover, #playButton:hover {
            background-color: #e63900;
            transform: scale(1.05);
        }
        #restart {
            display: none;
        }
        h1 {
            font-size: 36px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            animation: titleGlow 3s infinite;
        }
        #namePromptOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            display: none;
        }
        #namePrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 9999;
            display: none;
            text-align: center;
            pointer-events: auto;
        }
        #namePrompt input[type="text"] {
            padding: 5px;
            font-size: 16px;
            margin: 5px 0;
            width: 150px;
            font-family: 'Montserrat', sans-serif;
            pointer-events: auto;
            border: 2px solid transparent;
            box-sizing: border-box;
        }
        #namePrompt input[type="text"]:focus {
            border: 2px solid #ff4500;
            outline: none;
        }
        #namePrompt input[type="color"] {
            margin: 5px 0;
            width: 50px;
            height: 30px;
            border: none;
            cursor: pointer;
            pointer-events: auto;
        }
        #namePrompt select {
            padding: 5px;
            font-size: 14px;
            margin: 5px 0;
            width: 150px;
            font-family: 'Montserrat', sans-serif;
            pointer-events: auto;
        }
        #namePrompt button {
            padding: 5px 10px;
            background-color: #ff4500;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            pointer-events: auto;
        }
        #namePrompt button:hover {
            background-color: #e63900;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 5px #ff4500; }
            50% { box-shadow: 0 0 15px #ff4500; }
            100% { box-shadow: 0 0 5px #ff4500; }
        }
        @keyframes titleGlow {
            0% { text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); }
            50% { text-shadow: 0 0 20px rgba(255, 69, 0, 0.8); }
            100% { text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); }
        }
        @media (max-width: 850px) {
            canvas, #info {
                width: 90%;
                max-width: 800px;
            }
            #info {
                font-size: 18px;
            }
            h1 {
                font-size: 28px;
            }
            #restart, #playButton {
                font-size: 16px;
                padding: 8px 16px;
            }
            #namePrompt {
                width: 80%;
            }
            #namePrompt input[type="text"], #namePrompt select {
                width: 60%;
                font-size: 14px;
            }
            #namePrompt input[type="color"] {
                width: 40px;
                height: 25px;
            }
            #namePrompt button {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <h1>Brick Breaker Géocaching</h1>
    <div id="info">
        <span id="score">Score: 0</span>
        <span id="level">Niveau: 1</span>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="playButton">Jouer</button>
    <button id="restart">Recommencer</button>
    <div id="namePromptOverlay"></div>
    <div id="namePrompt">
        <div>
            <input type="text" id="playerName" placeholder="Entrez votre nom" maxlength="10" inputmode="text">
        </div>
        <div>
            <label for="paddleColor" style="font-size: 14px;">Couleur du vaisseau:</label>
            <input type="color" id="paddleColor" value="#00b7eb">
        </div>
        <div>
            <label for="ballColor" style="font-size: 14px;">Couleur de l'orbe:</label>
            <input type="color" id="ballColor" value="#00ffff">
        </div>
        <div>
            <label for="paddleShape" style="font-size: 14px;">Forme du vaisseau:</label>
            <select id="paddleShape">
                <option value="triangle">Triangulaire (Classique)</option>
                <option value="rectangle">Chasseur Rectangulaire</option>
            </select>
        </div>
        <button onclick="submitName()">OK</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Adjust canvas resolution for high-DPI displays
        const dpr = window.devicePixelRatio || 1;
        canvas.width = 800 * dpr;
        canvas.height = 600 * dpr;
        canvas.style.width = '800px';
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        // Enable anti-aliasing and smoothing
        ctx.imageSmoothingEnabled = true;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // Fallback for roundRect
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, width, height, radius) {
                ctx.beginPath();
                ctx.rect(x, y, width, height);
            };
        }

        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const restartButton = document.getElementById('restart');
        const playButton = document.getElementById('playButton');
        const info = document.getElementById('info');
        const namePromptOverlay = document.getElementById('namePromptOverlay');
        const namePrompt = document.getElementById('namePrompt');
        const playerNameInput = document.getElementById('playerName');
        const paddleColorInput = document.getElementById('paddleColor');
        const ballColorInput = document.getElementById('ballColor');
        const paddleShapeInput = document.getElementById('paddleShape');

        // Debug logs for visibility
        console.log("Canvas dimensions:", canvas.width, canvas.height);
        console.log("Canvas bounding rect:", canvas.getBoundingClientRect());
        console.log("Play button bounding rect:", playButton.getBoundingClientRect());
        console.log("Restart button bounding rect:", restartButton.getBoundingClientRect());

        // Paramètres du jeu
        let paddleHeight = 20;
        let paddleWidth = 90;
        let paddleX = (800 - paddleWidth) / 2;
        let paddleSpeed = 0;
        const paddleSpeedTarget = 6;
        const acceleration = 0.5;
        const deceleration = 0.5;
        const ballRadius = 8;
        let ballX = 800 / 2;
        let ballY = 600 - 30;
        let ballDX = 4;
        let ballDY = -4;
        let score = 0;
        let level = 1;
        let rightPressed = false;
        let leftPressed = false;
        let brickRowCount = 5;
        const brickColumnCount = 8;
        const brickWidth = 80;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;
        let gameOver = false;
        let gameWon = false;
        let showVictoryMessage = false;
        let animationFrameId;
        let gameStarted = false;
        let playerName = "Pilot";
        let paddleColor = "#00b7eb";
        let ballColor = "#00ffff";
        let paddleShape = "triangle";

        // Brick fade-in animation
        let brickFadeIn = 0;

        // Color-changing bricks
        let brickHueShift = 0;

        // Thruster particles
        let thrusterParticles = [];

        // Sound effects using Web Audio API
        let audioContext;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.error("Web Audio API not supported:", e);
        }

        function playSound(type) {
            if (!audioContext) return;

            const now = audioContext.currentTime;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'brickHit') {  // Fixed typo
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            } else if (type === 'paddleHit') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            } else if (type === 'gameOver') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(500, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 1.0);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                oscillator.start(now);
                oscillator.stop(now + 1.0);
            } else if (type === 'victory') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 1.0);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                oscillator.start(now);
                oscillator.stop(now + 1.0);
            }
        }

        // Nebula effect
        let nebulaBlobs = [];
        function initNebula() {
            for (let i = 0; i < 5; i++) {
                nebulaBlobs.push({
                    x: Math.random() * 800,
                    y: Math.random() * 600,
                    radius: Math.random() * 100 + 50,
                    color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 50 + 50}, ${Math.random() * 100 + 155}, 0.2)`,
                    dx: (Math.random() - 0.5) * 0.1,
                    dy: (Math.random() - 0.5) * 0.1
                });
            }
        }
        initNebula();

        // Étoiles pour le fond
        let stars = [];
        function initStars() {
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * 800,
                    y: Math.random() * 600,
                    radius: Math.random() * 1.5,
                    alpha: Math.random(),
                    dAlpha: Math.random() * 0.02 + 0.01
                });
            }
        }
        initStars();

        // Particules pour les effets
        let particles = [];
        let explosions = [];

        // Fond étoilé avec nebula et vignette
        function drawBackground() {
            console.log("Drawing background");
            ctx.fillStyle = '#0a0a1e';
            ctx.fillRect(0, 0, 800, 600);

            nebulaBlobs.forEach(blob => {
                blob.x += blob.dx;
                blob.y += blob.dy;
                if (blob.x < -blob.radius) blob.x = 800 + blob.radius;
                if (blob.x > 800 + blob.radius) blob.x = -blob.radius;
                if (blob.y < -blob.radius) blob.y = 600 + blob.radius;
                if (blob.y > 600 + blob.radius) blob.y = -blob.radius;

                const gradient = ctx.createRadialGradient(blob.x, blob.y, 0, blob.x, blob.y, blob.radius);
                gradient.addColorStop(0, blob.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.beginPath();
                ctx.arc(blob.x, blob.y, blob.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.closePath();
            });

            stars.forEach(star => {
                star.alpha += star.dAlpha;
                if (star.alpha > 1 || star.alpha < 0) star.dAlpha = -star.dAlpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.fill();
                ctx.closePath();
            });

            const vignette = ctx.createRadialGradient(400, 300, 0, 400, 300, 500);
            vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vignette.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, 800, 600);
        }

        // Système de particules pour les briques
        function createParticles(x, y, color) {
            if (!explosions) explosions = [];
            explosions.push({
                x: x + brickWidth / 2,
                y: y + brickHeight / 2,
                radius: 0,
                maxRadius: 30,
                alpha: 1
            });

            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x + brickWidth / 2,
                    y: y + brickHeight / 2,
                    radius: Math.random() * 3 + 1,
                    dx: (Math.random() - 0.5) * 5,
                    dy: (Math.random() - 0.5) * 5,
                    alpha: 1,
                    color: color,
                    type: Math.random() > 0.5 ? 'spark' : 'fragment'
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => {
                p.x += p.dx;
                p.y += p.dy;
                p.alpha -= 0.02;
                ctx.beginPath();
                if (p.type === 'spark') {
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                } else {
                    ctx.rect(p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2);
                }
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.fill();
                ctx.closePath();
            });

            explosions = explosions.filter(e => e.alpha > 0);
            explosions.forEach(e => {
                e.radius += 2;
                e.alpha -= 0.05;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${e.alpha})`;
                ctx.fill();
                ctx.closePath();
            });
        }

        // Thruster particles for paddle with color variation
        function createThrusterParticles() {
            if (!rightPressed && !leftPressed && paddleSpeed === 0) return;
            const direction = rightPressed ? 1 : paddleSpeed > 0 ? 1 : -1;
            const particleCount = Math.min(3, Math.floor(Math.abs(paddleSpeed) / 2));
            for (let i = 0; i < particleCount; i++) {
                const colorVariation = Math.random() > 0.5 ? '255,165,0' : '255,215,0';
                thrusterParticles.push({
                    x: paddleX + (direction > 0 ? 0 : paddleWidth),
                    y: 600 - paddleHeight + 10,
                    radius: Math.random() * 2 + 1,
                    dx: (Math.random() - 0.5) * 2 - direction * 2,
                    dy: Math.random() * 2 + 1,
                    alpha: 1,
                    color: colorVariation
                });
            }
        }

        function updateThrusterParticles() {
            thrusterParticles = thrusterParticles.filter(p => p.alpha > 0);
            thrusterParticles.forEach(p => {
                p.x += p.dx;
                p.y += p.dy;
                p.alpha -= 0.03;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${p.color}, ${p.alpha})`;
                ctx.fill();
                ctx.closePath();
            });
        }

        // Système de confettis pour la victoire
        let confetti = [];
        function createConfetti() {
            for (let i = 0; i < 100; i++) {
                confetti.push({
                    x: Math.random() * 800,
                    y: -Math.random() * 600,
                    size: Math.random() * 5 + 2,
                    dx: (Math.random() - 0.5) * 2,
                    dy: Math.random() * 2 + 1,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    rotation: Math.random() * 360,
                    dRotation: (Math.random() - 0.5) * 10
                });
            }
        }

        function updateConfetti() {
            ctx.globalAlpha = 1;
            confetti = confetti.filter(c => c.y < 600 + c.size);
            confetti.forEach(c => {
                c.x += c.dx;
                c.y += c.dy;
                c.rotation += c.dRotation;
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate((c.rotation * Math.PI) / 180);
                ctx.fillStyle = c.color;
                ctx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }

        
        const coordinatesData = {
            data: [88, 63, 58, 186, 60, 67, 56, 62, 65, 65, 42, 79, 58, 58, 60, 186, 62, 62, 56, 64, 67, 64]
        };

        
        function createDecoder() {
            const decodeMethod = `return function(codes, shift) {
                return codes.map(c => String.fromCharCode(c - shift)).join('');
            }`;
            try {
                return new Function(decodeMethod)();
            } catch (e) {
                console.error("Erreur lors de la création du décodeur :", e);
                return (codes, shift) => codes.map(c => String.fromCharCode(c - shift)).join('');
            }
        }

        const decoder = createDecoder();
        let decodedCoordinates = null;

        function decodeCoordinates() {
            if (!decodedCoordinates) {
                try {
                    const shift = 10;
                    decodedCoordinates = decoder(coordinatesData.data, shift);
                    console.log("Coordonnées décodées :", decodedCoordinates);
                } catch (e) {
                    console.error("Erreur lors du décodage des coordonnées :", e);
                    decodedCoordinates = "Erreur de décodage";
                }
            }
            return decodedCoordinates;
        }

        // Création des briques
        let bricks = [];
        function initBricks() {
            bricks = [];
            brickRowCount = 5 + level - 1;
            brickFadeIn = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1, hueOffset: Math.random() * 360 };
                }
            }
        }
        initBricks();

        // Gestion des touches
        function enableKeyListeners() {
            document.addEventListener('keydown', keyDownHandler, false);
            document.addEventListener('keyup', keyUpHandler, false);
        }

        function disableKeyListeners() {
            document.removeEventListener('keydown', keyDownHandler, false);
            document.removeEventListener('keyup', keyUpHandler, false);
        }

        restartButton.addEventListener('click', restartGame);

        // Ensure canvas can receive focus
        canvas.setAttribute('tabindex', '0');

        // Focus canvas on click to ensure key events are captured
        canvas.addEventListener('click', (e) => {
            if (namePrompt.style.display !== 'block') {
                canvas.focus();
                console.log("Canvas focused");
            }
            e.stopPropagation();
        });

        // Debug click events on the document to identify event capture
        document.addEventListener('click', (e) => {
            console.log("Document clicked, target:", e.target);
        });

        // Debug input field state
        console.log("Initial playerNameInput state:", {
            disabled: playerNameInput.disabled,
            readonly: playerNameInput.readOnly,
            display: window.getComputedStyle(playerNameInput).display,
            visibility: window.getComputedStyle(playerNameInput).visibility,
            pointerEvents: window.getComputedStyle(playerNameInput).pointerEvents
        });

        // Debug paddle shape select state
        console.log("Initial paddleShapeInput state:", {
            disabled: paddleShapeInput.disabled,
            display: window.getComputedStyle(paddleShapeInput).display,
            visibility: window.getComputedStyle(paddleShapeInput).visibility,
            pointerEvents: window.getComputedStyle(paddleShapeInput).pointerEvents,
            value: paddleShapeInput.value
        });

        // Ensure input field is editable
        playerNameInput.removeAttribute('disabled');
        playerNameInput.removeAttribute('readonly');
        playerNameInput.setAttribute('inputmode', 'text');

        // Handle Enter key for name prompt
        playerNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                submitName();
                console.log("Enter key pressed in name prompt");
            }
        });

        // Debug input as the user types
        playerNameInput.addEventListener('input', (e) => {
            console.log("Name input value:", playerNameInput.value);
        });

        // Debug focus and click events
        playerNameInput.addEventListener('focus', () => {
            console.log("Name input focused");
        });

        playerNameInput.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log("Name input clicked");
        });

        // Debug paddle shape selection
        paddleShapeInput.addEventListener('change', (e) => {
            console.log("Paddle shape changed to:", paddleShapeInput.value);
        });

        paddleShapeInput.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log("Paddle shape select clicked");
        });

        // Stop propagation on the prompt to prevent events from reaching other elements
        namePrompt.addEventListener('click', (e) => {
            e.stopPropagation();
            playerNameInput.focus();
            console.log("Name prompt clicked, focusing input");
        });

        if (playButton) {
            console.log("Adding event listener to playButton");
            playButton.addEventListener('click', () => {
                // Resume audio context on user interaction
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("AudioContext resumed");
                    }).catch(e => {
                        console.error("Failed to resume AudioContext:", e);
                    });
                }
                promptName();
            });
        } else {
            console.error("playButton element not found!");
        }

        function keyDownHandler(e) {
            e.preventDefault();
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
                console.log("Right key pressed, rightPressed:", rightPressed);
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
                console.log("Left key pressed, leftPressed:", leftPressed);
            }
        }

        function keyUpHandler(e) {
            e.preventDefault();
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
                console.log("Right key released, rightPressed:", rightPressed);
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
                console.log("Left key released, leftPressed:", leftPressed);
            }
        }

        function promptName() {
            console.log("Prompting for player name, paddle color, ball color, and paddle shape");
            namePromptOverlay.style.display = 'block';
            namePrompt.style.display = 'block';
            // Disable canvas key listeners while prompt is visible
            disableKeyListeners();
            // Retry focusing with a longer delay
            let focusAttempts = 0;
            const maxAttempts = 5;
            const focusInterval = setInterval(() => {
                playerNameInput.focus();
                console.log(`Attempt ${focusAttempts + 1} to focus name input`);
                focusAttempts++;
                if (document.activeElement === playerNameInput || focusAttempts >= maxAttempts) {
                    clearInterval(focusInterval);
                    console.log("Focus successful or max attempts reached");
                }
            }, 200);
        }

        window.submitName = function() {
            playerName = playerNameInput.value.trim();
            if (!playerName) playerName = "Pilot";
            paddleColor = paddleColorInput.value;
            ballColor = ballColorInput.value;
            paddleShape = paddleShapeInput.value;
            console.log("Player name set to:", playerName, "Paddle color set to:", paddleColor, "Ball color set to:", ballColor, "Paddle shape set to:", paddleShape);
            namePrompt.style.display = 'none';
            namePromptOverlay.style.display = 'none';
            // Re-enable canvas key listeners
            enableKeyListeners();
            startGame();
        };

        function startGame() {
            console.log("startGame called");
            gameStarted = true;
            playButton.style.display = 'none';
            restartButton.style.display = 'inline-block';
            info.style.display = 'flex';
            canvas.focus();
            console.log("Canvas focused after startGame");
            draw();
        }

        function restartGame() {
            console.log("Restarting game");
            gameOver = false;
            gameWon = false;
            showVictoryMessage = false;
            score = 0;
            level = 1;
            paddleWidth = 90;
            paddleX = (800 - paddleWidth) / 2;
            paddleSpeed = 0;
            ballDX = 4;
            ballDY = -4;
            scoreElement.textContent = `Score: ${score}`;
            levelElement.textContent = `Niveau: ${level}`;
            resetBall();
            initBricks();
            decodedCoordinates = null;
            particles = [];
            explosions = [];
            thrusterParticles = [];
            confetti = [];
            canvas.focus();
            console.log("Canvas focused after restartGame");
            draw();
        }

        function collisionDetection() {
            let bricksLeft = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        bricksLeft++;
                        if (ballX > b.x && ballX < b.x + brickWidth && ballY > b.y && ballY < b.y + brickHeight) {
                            ballDY = -ballDY;
                            b.status = 0;
                            score += 10;
                            scoreElement.textContent = `Score: ${score}`;
                            playSound('brickHit');
                            createParticles(b.x, b.y, `hsl(${b.hueOffset + brickHueShift}, 70%, 50%)`);
                            if (!showVictoryMessage && score >= 2000) {
                                showVictoryMessage = true;
                                gameWon = true;
                                console.log("Victoire : 2000 points atteints.");
                                playSound('victory');
                                createConfetti();
                                ballDX = 0;
                                ballDY = 0;
                            }
                        }
                    }
                }
            }
            if (bricksLeft === 0) {
                level++;
                levelElement.textContent = `Niveau: ${level}`;
                ballDX *= 1.1;
                ballDY *= 1.1;
                paddleWidth = Math.max(50, paddleWidth - 10);
                paddleX = (800 - paddleWidth) / 2;
                resetBall();
                initBricks();
            }
        }

        function resetBall() {
            ballX = 800 / 2;
            ballY = 600 - 30;
            ballDX = (ballDX > 0 ? 4 : -4) * (1 + level * 0.1);
            ballDY = -4 * (1 + level * 0.1);
        }

        let ballTrail = [];
        function drawBall() {
            console.log("Drawing ball at x:", ballX, "y:", ballY);
            ballTrail.push({ x: ballX, y: ballY });
            if (ballTrail.length > 10) ballTrail.shift();

            ballTrail.forEach((pos, index) => {
                const alpha = (index + 1) / ballTrail.length;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, ballRadius * alpha, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${parseInt(ballColor.slice(1, 3), 16)}, ${parseInt(ballColor.slice(3, 5), 16)}, ${parseInt(ballColor.slice(5, 7), 16)}, ${alpha * 0.3})`;
                ctx.fill();
                ctx.closePath();
            });

            const gradient = ctx.createRadialGradient(ballX, ballY, 0, ballX, ballY, ballRadius);
            gradient.addColorStop(0, ballColor);
            gradient.addColorStop(1, darkenColor(ballColor, 0.7));
            ctx.beginPath();
            ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 15;
            ctx.shadowColor = ballColor;
            ctx.fill();
            ctx.closePath();
        }

        let pulse = 0;
        let nameGlow = 0;
        function drawPaddle() {
            console.log("Drawing paddle at x:", paddleX, "y:", 600 - paddleHeight);
            pulse += 0.05;
            const glow = 5 + Math.sin(pulse) * 3;

            createThrusterParticles();
            updateThrusterParticles();

            const gradient = ctx.createLinearGradient(paddleX, 0, paddleX + paddleWidth, 0);
            gradient.addColorStop(0, paddleColor);
            gradient.addColorStop(1, darkenColor(paddleColor, 0.7));

            ctx.beginPath();
            if (paddleShape === "triangle") {
                ctx.moveTo(paddleX, 600);
                ctx.lineTo(paddleX + paddleWidth / 2, 600 - paddleHeight);
                ctx.lineTo(paddleX + paddleWidth, 600);
                ctx.closePath();
            } else if (paddleShape === "rectangle") {
                ctx.roundRect(paddleX, 600 - paddleHeight, paddleWidth, paddleHeight, 5);
                ctx.moveTo(paddleX + paddleWidth / 2 - 5, 600 - paddleHeight);
                ctx.lineTo(paddleX + paddleWidth / 2, 600 - paddleHeight - 5);
                ctx.lineTo(paddleX + paddleWidth / 2 + 5, 600 - paddleHeight);
            }
            ctx.fillStyle = gradient;
            ctx.shadowBlur = glow;
            ctx.shadowColor = paddleColor;
            ctx.fill();
            ctx.shadowBlur = 0;

            const engineGlow = 3 + Math.abs(paddleSpeed) * 0.5;
            const engineGradient = ctx.createRadialGradient(paddleX + paddleWidth / 2, 600, 0, paddleX + paddleWidth / 2, 600, 20);
            engineGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)');
            engineGradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
            ctx.beginPath();
            ctx.arc(paddleX + paddleWidth / 2, 600, 20, 0, Math.PI * 2);
            ctx.fillStyle = engineGradient;
            ctx.fill();
            ctx.closePath();

            nameGlow += 0.05;
            const glowIntensity = 2 + Math.sin(nameGlow) * 2;
            ctx.font = 'bold 10px Montserrat';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = glowIntensity;
            ctx.shadowColor = '#ffffff';
            ctx.fillText(playerName, paddleX + paddleWidth / 2, 600 - paddleHeight / 2);
            ctx.shadowBlur = 0;
        }

        // Dessin des briques avec changement de couleur
        function drawBricks() {
            if (brickFadeIn < 1) brickFadeIn += 0.02;
            brickHueShift = (brickHueShift + 1) % 360;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;

                        const hue = (bricks[c][r].hueOffset + brickHueShift) % 360;
                        const baseColor = `hsl(${hue}, 70%, 50%)`;
                        const darkenedColor = `hsl(${hue}, 70%, 35%)`;

                        const gradient = ctx.createLinearGradient(brickX, brickY, brickX, brickY + brickHeight);
                        gradient.addColorStop(0, baseColor);
                        gradient.addColorStop(1, darkenedColor);
                        ctx.globalAlpha = brickFadeIn;
                        ctx.beginPath();
                        ctx.roundRect(brickX, brickY, brickWidth, brickHeight, 5);
                        ctx.fillStyle = gradient;
                        ctx.shadowBlur = 3;
                        ctx.shadowColor = baseColor;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.closePath();
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        function darkenColor(color, factor) {
            const r = Math.floor(parseInt(color.slice(1, 3), 16) * factor);
            const g = Math.floor(parseInt(color.slice(3, 5), 16) * factor);
            const b = Math.floor(parseInt(color.slice(5, 7), 16) * factor);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        let shakeOffset = 0;
        let shakeTimerGameOver = 0;
        function drawGameOver() {
            if (shakeTimerGameOver > 0) {
                shakeOffset = (Math.random() - 0.5) * 10;
                shakeTimerGameOver--;
            } else {
                shakeOffset = 0;
            }
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, 800, 600);
            ctx.font = 'bold 60px Montserrat';
            ctx.fillStyle = '#ff4500';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#ff4500';
            ctx.fillText('Game Over', 800 / 2 + shakeOffset, 600 / 2);
            ctx.font = 'bold 30px Montserrat';
            ctx.fillText(`Score final: ${score}`, 800 / 2 + shakeOffset, 600 / 2 + 60);
            ctx.shadowBlur = 0;
        }

        let fadeIn = 0;
        function drawVictoryMessage() {
            console.log("Affichage du message de victoire");
            try {
                if (fadeIn < 1) fadeIn += 0.02;
                ctx.globalAlpha = fadeIn;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 800, 600);
                ctx.font = 'bold 50px Montserrat';
                ctx.fillStyle = '#00ff7f';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#00ff7f';
                ctx.fillText(`Bravo, ${playerName} !!!`, 800 / 2, 600 / 2 - 60);
                ctx.font = 'bold 30px Montserrat';
                ctx.fillText('Rendez-vous au point', 800 / 2, 600 / 2);
                const coordinates = decodeCoordinates();
                ctx.fillText(coordinates || "Coordonnées non disponibles", 800 / 2, 600 / 2 + 60);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                updateConfetti();
            } catch (e) {
                console.error("Erreur lors de l'affichage du message de victoire :", e);
            }
        }

        function draw() {
            console.log("Game loop running, frame:", animationFrameId, "gameStarted:", gameStarted, "gameOver:", gameOver, "gameWon:", gameWon);
            try {
                ctx.save();

                drawBackground();
                updateParticles();

                if (!gameStarted) {
                    console.log("Game not started, showing start screen");
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, 800, 600);
                    ctx.restore();
                    animationFrameId = requestAnimationFrame(draw);
                    return;
                }

                if (gameWon) {
                    console.log("Jeu gagné, affichage du message de victoire");
                    drawVictoryMessage();
                    ctx.restore();
                    animationFrameId = requestAnimationFrame(draw);
                    return;
                }

                if (gameOver) {
                    console.log("Jeu terminé, affichage de l'écran de game over");
                    drawGameOver();
                    ctx.restore();
                    cancelAnimationFrame(animationFrameId);
                    return;
                }

                drawBricks();
                drawBall();
                drawPaddle();
                collisionDetection();

                ballX += ballDX;
                ballY += ballDY;

                if (ballX + ballRadius > 800 || ballX - ballRadius < 0) {
                    ballDX = -ballDX;
                }
                if (ballY - ballRadius < 0) {
                    ballDY = -ballDY;
                } else if (ballY + ballRadius > 600 - paddleHeight) {
                    if (ballX > paddleX && ballX < paddleX + paddleWidth) {
                        ballDY = -ballDY;
                        playSound('paddleHit');
                    } else if (ballY + ballRadius > 600) {
                        gameOver = true;
                        playSound('gameOver');
                        shakeTimerGameOver = 30;
                        drawGameOver();
                        ctx.restore();
                        cancelAnimationFrame(animationFrameId);
                        return;
                    }
                }

                console.log("Paddle movement - rightPressed:", rightPressed, "leftPressed:", leftPressed, "paddleX:", paddleX, "paddleSpeed:", paddleSpeed);

                if (rightPressed && paddleX < 800 - paddleWidth) {
                    paddleX += paddleSpeedTarget;
                    paddleSpeed = paddleSpeedTarget;
                    console.log("Moving right, new paddleX:", paddleX);
                } else if (leftPressed && paddleX > 0) {
                    paddleX -= paddleSpeedTarget;
                    paddleSpeed = -paddleSpeedTarget;
                    console.log("Moving left, new paddleX:", paddleX);
                } else {
                    paddleSpeed = 0;
                }

                paddleX = Math.max(0, Math.min(paddleX, 800 - paddleWidth));

                ctx.restore();
                animationFrameId = requestAnimationFrame(draw);
            } catch (e) {
                console.error("Erreur dans la boucle de jeu:", e);
            }
        }

        console.log("Starting animation");
        draw();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9378192d1b47ed87',t:'MTc0NTg1OTQ0Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>
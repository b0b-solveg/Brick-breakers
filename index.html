<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
</script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Breaker Géocaching</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            text-align: center;
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to bottom, #1e3c72, #2a5298);
            color: #fff;
            margin: 0;
            padding: 20px;
        }
        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #333;
        }
        #info {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin: 0 auto 10px;
            font-size: 24px;
        }
        #restart {
            background-color: #ff4500;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #restart:hover {
            background-color: #e63900;
        }
        h1 {
            font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <h1>Brick Breaker Géocaching</h1>
    <div id="info">
        <span id="score">Score: 0</span>
        <span id="level">Niveau: 1</span>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="restart">Recommencer</button>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const restartButton = document.getElementById('restart');

        // Paramètres du jeu
        let paddleHeight = 10;
        let paddleWidth = 100;
        let paddleX = (canvas.width - paddleWidth) / 2;
        const ballRadius = 10;
        let ballX = canvas.width / 2;
        let ballY = canvas.height - 30;
        let ballDX = 4;
        let ballDY = -4;
        let score = 0;
        let level = 1;
        let rightPressed = false;
        let leftPressed = false;
        let brickRowCount = 5;
        const brickColumnCount = 8;
        const brickWidth = 80;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;
        let gameOver = false;
        let gameWon = false;
        let showVictoryMessage = false;
        let animationFrameId;

        // Couleurs des briques par niveau
        const brickColors = ['#ff6347', '#ffd700', '#00ff7f', '#1e90ff', '#ff00ff'];

        // Chargement des sons
        const brickHitSound = new Audio('brick_hit.mp3');
        const paddleHitSound = new Audio('paddle_hit.mp3');
        const gameOverSound = new Audio('game_over.mp3');
        const victorySound = new Audio('victory.mp3'); // Son de victoire

        
        const coordinatesData = {
            data: [88, 63, 58, 186, 60, 67, 56, 62, 65, 65, 42, 79, 58, 58, 60, 186, 62, 62, 56, 64, 67, 64]
        };

        
        function createDecoder() {
            const decodeMethod = `return function(codes, shift) {
                return codes.map(c => String.fromCharCode(c - shift)).join('');
            }`;
            try {
                return new Function(decodeMethod)();
            } catch (e) {
                console.error("Erreur lors de la création du décodeur :", e);
                return (codes, shift) => codes.map(c => String.fromCharCode(c - shift)).join('');
            }
        }

        
        const decoder = createDecoder();
        let decodedCoordinates = null;

        function decodeCoordinates() {
            if (!decodedCoordinates) {
                try {
                    const shift = 10;
                    decodedCoordinates = decoder(coordinatesData.data, shift);
                    console.log("Coordonnées décodées :", decodedCoordinates);
                } catch (e) {
                    console.error("Erreur lors du décodage des coordonnées :", e);
                    decodedCoordinates = "Erreur de décodage";
                }
            }
            return decodedCoordinates;
        }

        // Création des briques
        let bricks = [];
        function initBricks() {
            bricks = [];
            brickRowCount = 5 + level - 1;
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }
        }
        initBricks();

        // Gestion des touches
        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);
        restartButton.addEventListener('click', restartGame);

        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }

        // Réinitialisation du jeu
        function restartGame() {
            gameOver = false;
            gameWon = false;
            showVictoryMessage = false;
            score = 0;
            level = 1;
            paddleWidth = 100;
            paddleX = (canvas.width - paddleWidth) / 2;
            ballDX = 4;
            ballDY = -4;
            scoreElement.textContent = `Score: ${score}`;
            levelElement.textContent = `Niveau: ${level}`;
            resetBall();
            initBricks();
            decodedCoordinates = null; // Réinitialiser le cache des coordonnées
            draw();
        }

        // Détection des collisions
        function collisionDetection() {
            let bricksLeft = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        bricksLeft++;
                        if (ballX > b.x && ballX < b.x + brickWidth && ballY > b.y && ballY < b.y + brickHeight) {
                            ballDY = -ballDY;
                            b.status = 0;
                            score += 10;
                            scoreElement.textContent = `Score: ${score}`;
                            brickHitSound.play().catch(e => console.log('Erreur son brique:', e));
                            // Vérifier si le score atteint 2000
                            if (!showVictoryMessage && score >= 2000) {
                                showVictoryMessage = true;
                                gameWon = true;
                                console.log("Victoire : 2000 points atteints.");
                                // Jouer le son de victoire
                                victorySound.play().catch(e => console.log('Erreur son victoire:', e));
                                // Arrêter le mouvement de la balle
                                ballDX = 0;
                                ballDY = 0;
                            }
                        }
                    }
                }
            }
            if (bricksLeft === 0) {
                level++;
                levelElement.textContent = `Niveau: ${level}`;
                ballDX *= 1.1;
                ballDY *= 1.1;
                paddleWidth = Math.max(50, paddleWidth - 10);
                paddleX = (canvas.width - paddleWidth) / 2;
                resetBall();
                initBricks();
            }
        }

        // Réinitialisation de la balle
        function resetBall() {
            ballX = canvas.width / 2;
            ballY = canvas.height - 30;
            ballDX = (ballDX > 0 ? 4 : -4) * (1 + level * 0.1);
            ballDY = -4 * (1 + level * 0.1);
        }

        // Dessin des éléments
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ff4500';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff4500';
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = '#00b7eb';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00b7eb';
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = brickColors[r % brickColors.length];
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = brickColors[r % brickColors.length];
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.closePath();
                    }
                }
            }
        }

        // Affichage de "Game Over"
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 60px Roboto';
            ctx.fillStyle = '#ff4500';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff4500';
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
            ctx.font = 'bold 30px Roboto';
            ctx.fillText(`Score final: ${score}`, canvas.width / 2, canvas.height / 2 + 60);
            ctx.shadowBlur = 0;
        }

        // Affichage de la victoire
        function drawVictoryMessage() {
            console.log("Affichage du message de victoire");
            try {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 50px Roboto';
                ctx.fillStyle = '#00ff7f';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ff7f';
                ctx.fillText('Bravo !!!', canvas.width / 2, canvas.height / 2 - 60);
                ctx.font = 'bold 30px Roboto';
                ctx.fillText('Rendez-vous au point', canvas.width / 2, canvas.height / 2);
                const coordinates = decodeCoordinates();
                ctx.fillText(coordinates || "Coordonnées non disponibles", canvas.width / 2, canvas.height / 2 + 60);
                ctx.shadowBlur = 0;
            } catch (e) {
                console.error("Erreur lors de l'affichage du message de victoire :", e);
            }
        }

        // Boucle principale du jeu
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Afficher le message de victoire si le jeu est gagné
            if (gameWon) {
                console.log("Jeu gagné, affichage du message de victoire");
                drawVictoryMessage();
                animationFrameId = requestAnimationFrame(draw); // Continuer la boucle pour garder le message affiché
                return;
            }

            // Si le jeu est terminé (défaite), afficher l'écran de game over
            if (gameOver) {
                console.log("Jeu terminé, affichage de l'écran de game over");
                drawGameOver();
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // Dessiner les éléments du jeu
            drawBricks();
            drawBall();
            drawPaddle();
            collisionDetection();

            // Mouvement de la balle
            ballX += ballDX;
            ballY += ballDY;

            // Rebond sur les murs
            if (ballX + ballRadius > canvas.width || ballX - ballRadius < 0) {
                ballDX = -ballDX;
            }
            if (ballY - ballRadius < 0) {
                ballDY = -ballDY;
            } else if (ballY + ballRadius > canvas.height - paddleHeight) {
                if (ballX > paddleX && ballX < paddleX + paddleWidth) {
                    ballDY = -ballDY;
                    paddleHitSound.play().catch(e => console.log('Erreur son raquette:', e));
                } else if (ballY + ballRadius > canvas.height) {
                    gameOver = true;
                    gameOverSound.play().catch(e => console.log('Erreur son game over:', e));
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawGameOver();
                    cancelAnimationFrame(animationFrameId);
                    return;
                }
            }

            // Mouvement de la raquette
            if (rightPressed && paddleX < canvas.width - paddleWidth) {
                paddleX += 7;
            } else if (leftPressed && paddleX > 0) {
                paddleX -= 7;
            }

            animationFrameId = requestAnimationFrame(draw);
        }

        // Démarrer le jeu
        draw();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9378192d1b47ed87',t:'MTc0NTg1OTQ0Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>